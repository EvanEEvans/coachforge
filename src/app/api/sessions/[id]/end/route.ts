import { createServiceSupabase } from "@/lib/supabase/server";
import { createServerSupabase } from "@/lib/supabase/server";
import { processSession } from "@/lib/ai/process-session";
import { NextResponse } from "next/server";

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  const supabase = createServerSupabase();
  const serviceSupabase = createServiceSupabase();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const sessionId = params.id;
  console.log("[END SESSION] Starting for session:", sessionId);

  const { data: session } = await supabase
    .from("sessions")
    .select("*, client:clients(*)")
    .eq("id", sessionId)
    .eq("coach_id", user.id)
    .single();

  if (!session) return NextResponse.json({ error: "Session not found" }, { status: 404 });

  await supabase.from("sessions").update({
    status: "processing",
    ended_at: new Date().toISOString(),
    duration_seconds: session.started_at
      ? Math.round((Date.now() - new Date(session.started_at).getTime()) / 1000)
      : null,
  }).eq("id", sessionId);

  const transcript = session.transcript_text || "No transcript available. This session was not recorded.";
  console.log("[END SESSION] Transcript length:", transcript.length);

  try {
    console.log("[END SESSION] Running AI pipeline...");
    const result = await processSession(transcript, session.client, session.session_number);
    console.log("[END SESSION] AI pipeline complete. Summary length:", result.summary?.length);

    await serviceSupabase.from("sessions").update({
      status: "completed",
      summary: result.summary,
      summary_structured: result.summary_structured,
      mood_score: result.mood_score,
      energy_score: result.energy_score,
      engagement_score: result.engagement_score,
      breakthrough_flagged: result.breakthrough_flagged,
      followup_email_body: result.followup_email_body,
    }).eq("id", sessionId);

    if (result.action_items.length > 0) {
      const actionRows = result.action_items.map((item: any) => ({
        session_id: sessionId,
        client_id: session.client_id,
        coach_id: user.id,
        task: item.task,
        priority: item.priority,
        due_date: item.due_date_suggestion,
      }));
      await serviceSupabase.from("action_items").insert(actionRows);
    }

    await serviceSupabase.from("client_progress").insert([
      { client_id: session.client_id, session_id: sessionId, date: new Date().toISOString().split("T")[0], type: "mood", value: result.mood_score },
      { client_id: session.client_id, session_id: sessionId, date: new Date().toISOString().split("T")[0], type: "energy", value: result.energy_score },
    ]);

    await serviceSupabase.from("clients").update({
      session_count: (session.client.session_count || 0) + 1,
      last_session_at: new Date().toISOString(),
      current_streak: (session.client.current_streak || 0) + 1,
    }).eq("id", session.client_id);

    console.log("[END SESSION] Sending follow-up email to:", session.client.email);
    try {
      const { Resend } = require("resend");
      const resend = new Resend(process.env.RESEND_API_KEY);
      const { data: coachProfile } = await serviceSupabase.from("profiles").select("full_name").eq("id", user.id).single();
      const fromEmail = process.env.RESEND_FROM_EMAIL || "onboarding@resend.dev";
      console.log("[END SESSION] From:", fromEmail, "To:", session.client.email);

      const emailResult = await resend.emails.send({
        from: coachProfile?.full_name ? `${coachProfile.full_name} via CoachForge <${fromEmail}>` : `CoachForge <${fromEmail}>`,
        to: session.client.email,
        subject: `Your session recap`,
        html: `<div style="font-family:-apple-system,sans-serif;max-width:600px;margin:0 auto;color:#1C1917;"><p style="font-size:16px;">Hi ${session.client.full_name.split(" ")[0]},</p><div style="font-size:15px;line-height:1.8;color:#57534E;white-space:pre-wrap;">${result.followup_email_body}</div><hr style="border:none;border-top:1px solid #E7E5E4;margin:24px 0;" /><p style="font-size:13px;color:#A8A29E;">This email was generated by CoachForge AI based on your session.</p></div>`,
      });
      console.log("[END SESSION] Email result:", JSON.stringify(emailResult));

      await serviceSupabase.from("sessions").update({
        followup_email_sent: true,
        followup_email_sent_at: new Date().toISOString(),
      }).eq("id", sessionId);
    } catch (emailError: any) {
      console.error("[END SESSION] Email error:", emailError?.message || emailError);
    }

    return NextResponse.json({ success: true, status: "completed" });
  } catch (error: any) {
    console.error("[END SESSION] AI pipeline error:", error?.message || error);
    await serviceSupabase.from("sessions").update({
      status: "completed",
      summary: "Processing error: " + (error?.message || "Unknown error"),
    }).eq("id", sessionId);
    return NextResponse.json({ error: "Processing failed: " + (error?.message || "Unknown") }, { status: 500 });
  }
}
